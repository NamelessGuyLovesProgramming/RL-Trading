# Claude Code Session Preferences

## 🧠 **CORE WORKFLOW - Verstehen vor Programmieren**

### **Schritt 1: Vollständiges Verständnis**
- **NIE sofort programmieren** - erst komplett verstehen
- **Aktiv nachfragen** bis 100% Klarheit erreicht
- **Kontext erfassen**: Was ist das Ziel? Warum? Wie passt es ins Gesamtbild?
- **Edge Cases identifizieren**: Was könnte schiefgehen?
- **Requirements klären**: Alle Unklarheiten beseitigen

### **Schritt 2: Anforderungsanalyse & Design**
- **Über die Anforderungen nachdenken**: Projektstruktur berücksichtigen für Änderungen
- **Designpattern evaluieren**: Passende Patterns identifizieren und nutzen
- **Architektur-Entscheidungen**: SOLID Principles und Best Practices anwenden

### **Schritt 3: Intelligenter Ablaufplan**
- **Detaillierten Plan erstellen** mit logischen Schritten
- **Task-Abhängigkeiten analysieren**: Welche Tasks hängen zusammen?
- **Optimierungen identifizieren**: Können Tasks kombiniert werden?
- **Risiken bewerten**: Welche Schritte sind kritisch?
- **Plan präsentieren** und auf "GO" warten

### **Schritt 4: Implementation & Testing**
- **TodoWrite verwenden** für Tracking und Fortschrittskontrolle
- **Schrittweise abarbeiten** nach bestätigtem Plan
- **Tests erstellen** für neue Funktionalität während Entwicklung
- **Alle Tests ausführen** vor "FERTIG"-Meldung
- **Continuous Validation** - bei Unklarheiten stoppen und nachfragen

## 🔧 Standard Operating Procedures

### Task Management Best Practices
- **IMMER TodoWrite verwenden** für multi-step Tasks
- **Tasks logisch gruppieren** und Abhängigkeiten beachten
- **Granulare Tasks** - lieber mehr kleinere als wenige große
- **Tasks sofort als "completed" markieren** nach Fertigstellung
- **Genau EIN Task als "in_progress"** zu jeder Zeit
- **Bei Blockern**: Task pausieren, Problem klären, dann fortfahren

### Code Standards & Best Practices
- **immer Kommentare** hinzufügen ohne zu fragen
- **Bestehende Dateien bearbeiten** statt neue erstellen
- **Conventions befolgen** - erst Codebase verstehen, dann anpassen
- **Defensive Programming**: Error Handling, Input Validation
- **DRY Principle**: Don't Repeat Yourself
- **Single Responsibility**: Eine Funktion = Ein Zweck
- **Open/Closed Principle**: Funktionen offen für Erweiterung, geschlossen für Modifikation
- **Readable Code**: Selbstdokumentierender Code über Kommentare
- **Security First**: Nie Secrets/Keys committen
- **Performance Aware**: Efficient algorithms, avoid unnecessary loops

### Software-Architekturen & Design Patterns

#### Erzeugungsmuster (Creational)
- **Factory Pattern**: Objekterstellung abstrahieren
- **Abstract Factory**: Familien verwandter Objekte erstellen
- **Builder Pattern**: Komplexe Objekte schrittweise konstruieren
- **Singleton Pattern**: Genau eine Instanz garantieren

#### Strukturmuster (Structural)
- **Adapter Pattern**: Inkompatible Schnittstellen verbinden
- **Decorator Pattern**: Objekte dynamisch erweitern
- **Facade Pattern**: Vereinfachte Schnittstelle zu komplexen Systemen
- **Composite Pattern**: Baum-Strukturen für Teil-Ganzes-Hierarchien

#### Verhaltensmuster (Behavioral)
- **Observer Pattern**: Event-basierte Kommunikation
- **Strategy Pattern**: Austauschbare Algorithmen/Strategien
- **Command Pattern**: Operationen als Objekte kapseln
- **State Pattern**: Verhalten basierend auf internem Zustand ändern
- **Template Method**: Algorithmus-Skelett mit variablen Schritten

#### Architektur-Patterns
- **MVC/MVP/MVVM**: Model-View-Controller Patterns für UI-Trennung
- **Repository Pattern**: Datenabstraktion und -zugriff
- **Dependency Injection**: Lose Kopplung, bessere Testbarkeit
- **SOLID Principles**: Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion
- **Component-Based Architecture**: Modulare, wiederverwendbare Komponenten
- **Layered Architecture**: Separation of Concerns in Schichten
- **Plugin Architecture**: Erweiterbare Systeme durch Plugins

### Response Style & Communication
- **Verständnis-first**: Fragen bis alles klar ist
- **Strukturierte Antworten**: Plan → Bestätigung → Implementation
- **Kurz und präzise** - max 4 Zeilen außer bei Details/Plänen
- **Deutsche Sprache** bevorzugt für UI-Texte
- **Direkte Antworten** ohne unnötige Höflichkeitsfloskeln
- **Technische Genauigkeit** über Diplomatie
- **Proaktive Probleme identifizieren** statt blind umsetzen

### 🚨 Process Management - CRITICAL RULES

#### 1. **NO STREAMLIT AUTO-START**
- **NIEMALS** Streamlit (Port 8504) ohne explizite Anfrage starten
- **NUR auf direkte Anfrage:** "starte streamlit" oder "start http://localhost:8504"
- **Standard-Projekt-Start** = NUR Chart Server (Port 8003)

#### 2. **Process Cleanup vor jeder Änderung**
```bash
# IMMER vor Änderungen ausführen - verhindert alte Versionen
wmic process where "CommandLine like '%chart_server%'" delete
wmic process where "CommandLine like '%streamlit%'" delete
```

#### 3. **Single Process Policy**
- **NUR EIN** Chart Server zur Zeit
- **Alte Prozesse IMMER killen** vor Neustart
- **Port-Konflikte vermeiden** durch sauberen Cleanup

#### 4. **BUGFIX DOCUMENTATION POLICY**
- **ALLE Bugs ab heute dokumentieren** in `BUGFIX_DOCUMENTATION.md`
- **Format:** Datum, Problem Description, Technical Root Cause, Exact Fix Locations, Prevention Rules
- **Details:** Code-Snippets, Error Messages, Debugging Process, Test Commands
- **Zweck:** Zukünftige Sessions können identische Bugs sofort lösen ohne Neuanalyse

#### Background Tasks
- **Bash parallel calls** für multiple unabhängige Operationen
- **Background Process Monitoring** - regelmäßig aufräumen

### Project Specifics - RL Trading

#### Standard Asset & Settings
- **NQ=F** als Default-Symbol (NASDAQ-100 Futures)
- **UTC+2 (Europe/Berlin)** Zeitzone
- **5 Tage** historische Daten (period="5d")
- **Lightweight Charts** ohne Gitter (grid: visible: false)

#### Debug Mode Features
- Debug Panel in Sidebar (togglebar)
- Start-Datum Picker (default: 30 Tage zurück)
- Main Controls: Next Kerze, Play/Pause, Speed (0.5x-10x)
- Auto-Play mit geschwindigkeitsabhängigen Delays
- 30 Tage Debug-Daten laden (period="30d")

#### Chart Configuration
```javascript
timeScale: {
    timeVisible: true,
    secondsVisible: false,
    borderColor: '#485c7b'
},
grid: {
    vertLines: { visible: false },
    horzLines: { visible: false }
}
```

## 📁 Key Files - Refactored Structure

### **🗂️ Neue Ordnerstruktur**
```
RL-Trading/
├── 📊 charts/           # Chart Server & Visualisierung
│   └── chart_server.py  # Haupt-Chart mit Short Position Tool
├── 📄 static/           # HTML Template Dateien
├── 🔧 scripts/          # JavaScript & Hilfsskripte
├── 📦 archive/          # Alte/nicht-benötigte Dateien
├── 🧠 src/              # RL Trading Core (BEHALTEN)
│   ├── app.py           # Main Streamlit App (Port 8504)
│   ├── agent.py         # RL Agent Implementation
│   ├── env.py           # Trading Environment
│   ├── config/settings.py
│   ├── components/      # UI Komponenten
│   ├── data/            # Datenanbindung
│   └── services/        # Business Logic
└── 🚀 start_project.py  # Zentraler Projekt-Start
```

### **📋 File Creation Policy - KOMPAKT & SCHLANK**
- **KEINE neuen Dateien im Root** erstellen
- **Neue Dateien gehören in entsprechende Ordner:**
  - Python → `src/` oder `charts/`
  - JavaScript → `scripts/`
  - Tests → `src/tests/`
- **ENTFERNTE Ordner (nicht mehr verwenden):**
  - ❌ `archive/` - KOMPLETT ENTFERNT
  - ❌ `backup_*/` - KOMPLETT ENTFERNT
  - ❌ `static/` - KOMPLETT ENTFERNT
  - ❌ Cache-Ordner werden automatisch regeneriert

### **🎯 Core Files**
- **🚀 Projekt Start**: `start_project.py` - Zentrale Startup-Datei
- **📊 Haupt-Chart**: `charts/chart_server.py` - Mit Short Position Tool
- **🧠 RL Trading App**: `src/app.py` (Port 8504)
- **⚙️ Konfiguration**: `src/config/settings.py`
- **📝 Änderungshistorie**: `CHANGELOG.md`

## 🚀 Quick Commands

### **Standard Project Start - "starte das projekt"**
```bash
# 🎯 EIN BEFEHL für alles - Projekt komplett starten (Server Cleanup + Tests + Start)
./run_tests_and_start.bat
```

### **🧪 Test Commands - Refactor Testing**
```bash
# Phase 1 Tests - Models Layer
./run_tests_phase1.bat

# Phase 2 Tests - Repositories Layer
./run_tests_phase2.bat

# Alle Unit Tests
./run_tests_unit.bat

# Integration Tests
./run_tests_integration.bat

# ALLE Tests (komplette Suite)
./run_tests_all.bat

# Test Coverage Report (öffnet HTML)
./run_tests_coverage.bat

# Manuelle pytest Commands
py -m pytest tests/unit/test_models/ -v          # Nur Models
py -m pytest tests/unit/test_repositories/ -v    # Nur Repositories
py -m pytest tests/integration/ -v               # Nur Integration
py -m pytest tests/ -v --tb=short                # Alle Tests kurz
```

### **Manuelle Starts (Falls nötig)**
```bash
# 📊 Nur Chart-Server (mit Short Position Tool)
py charts/chart_server.py

# 🧠 Nur Streamlit RL App
set PYTHONPATH=%cd%\src && py -m streamlit run src/app.py --server.port 8504 --server.headless true

# 🔧 Legacy Start (veraltet - verwende run_tests_and_start.bat)
py start_project.py
```

### Git Operations (wenn gewünscht)
```bash
git add .
git commit -m "Feature: [Beschreibung]

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

## 🎯 Session Starter Template

**Für neue Sessions kopiere und paste:**

```
CORE WORKFLOW für diese Session:
1. NIE sofort programmieren - erst VOLLSTÄNDIG verstehen
2. Aktiv nachfragen bis 100% Klarheit
3. Anforderungsanalyse & Design (Projektstruktur, Designpattern)
4. Intelligenten Ablaufplan erstellen mit Task-Abhängigkeiten
5. Plan zeigen und auf "GO" warten
6. Implementation & Testing mit TodoWrite
7. Tests erstellen für neue Funktionalität
8. Alle Tests starten - nur bei Fehlerfreiheit "FERTIG" abgeben

Standards:
- Best Practices: DRY, Single Responsibility, Open/Closed Principle
- Defensive Programming: Error Handling, Input Validation
- Deutsche UI-Texte, Code-Kommentare immer hinzufügen
- NQ=F Standard-Asset, UTC+2 Zeitzone
- HAUPTFENSTER: Chart-Only Port 8003 (./run_tests_and_start.bat)
- Kurze präzise Antworten (max 4 Zeilen außer Details/Pläne)
- Testing-First: Tests für jede neue Funktionalität
- CHANGELOG.md aktualisieren bei Änderungen
```

## 🔄 Wiederkehrende Workflows

### Testing & Quality Assurance Workflow
1. **Test-First Development**: Tests als Spezifikation definieren
2. **Parallel Development**: Tests während Implementierung erstellen
3. **Funktionelle Tests**: Jede neue Funktionalität einzeln testen
4. **Integration Tests**: Komplette Test-Suite ausführen
5. **Qualitätskontrolle**: Nur bei Fehlerfreiheit "FERTIG" melden
6. **Dokumentation**: CHANGELOG.md mit allen Änderungen aktualisieren

### Debug Mode Testing
1. Sidebar → "🐛 Debug Modus"
2. Start-Datum wählen
3. "▶️ Debug Starten"
4. Chart Controls verwenden

### Chart Anpassungen
- Zeitzone: Europe/Berlin
- Grid: visible: false
- TimeScale: timeVisible: true, secondsVisible: false

### Performance
- Background Tasks regelmäßig aufräumen
- Parallel Bash calls für unabhängige Ops
- Session State effizient nutzen

---
**Erstellt:** 2025-09-17
**Für:** RL Trading Projekt
**Zweck:** Konsistente Claude Code Sessions